<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>面试汇总</title>
</head>
<body>
<script>

===========数组方法===========
栈和队列
1.队列先进先出，栈先进后出。
2.对插入和删除操作的"限定"：
    栈是限定只能在表的一端进行插入和删除操作的线性表。
    队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。
3、操作方法：
    队列操作的方法  shift unshift
    栈操作 pop push
    eg:
        var list = [0,1,2]
        shift():
            删除数组的第一个元素,返回删除的值。这里是0
        unshift(3,4):
            把参数加载数组的前面，返回数组的长度。现在list中是3,4,0,1,2，返回值为5
        pop():
            删除数组的最后一个元素，返回删除的值。这里是2
        push(3):
            将参数加载到数组的最后，返回数组的长度，现在List中时：0,1,2,3，返回值为4
        concat(3,4):
            把两个数组拼接起来,返回一个数组副本，值为0,1,2,3,4
        splice(index,howmany,item1,.....,itemX):
            howmany删除项目数量，item为添加的项目
        sort():
            是按照字符编码的顺序进行排序,中间加函数可实现乱序 里面传一个函数 a b  a>b 看返回值 返回正值就调换顺序  返回负值不掉换
        reverse():
            方法用于颠倒数组中元素的顺序。
        join():
            方法用于把数组中的所有元素放入一个字符串。
        toString():
            方法可把数组转换为字符串，并返回结果。加radix，也可以转化成十进制


==========字符串常见方法========
charCodeAt(index):
    方法返回一个整数，代表指定位置字符的Unicode编码。
fromCharCode(code1,code2...):
    方法从一些Unicode字符串中返回一个字符串。
charAt(index):
    方法返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串。
slice(start,end):
    方法返回字符串的片段。 算头不算尾。
substring(start,end):
    方法用于提取字符串中介于两个指定下标之间的字符。算头不算尾。
substr(start,length):
    方法返回一个从指定位置开始的指定长度的子字符串。
indexOf(substr,startIndex):
    方法放回String对象内第一次出现子字符串位置。没有找到子字符串，则返回-1。
split(separator,limit):
    将一个字符串分割为子字符串，然后将结果作为字符串数组返回。limit该值用来限制返回数组中的元素个数。
concat(string1,string2...):
    方法返回字符串值，该值包含了两个或多个提供的字符串的连接。
search():
    方法返回与正则表达式查找内容匹配的第一个字符串的位置。
toLowerCase()/toUpperCase():
    改变字符串中的字母大小写


==========this的指向==========
1.谁调用指向谁
2.定时器那种指向window
3.call apply:
    对于apply和call两者在作用上是相同的，但两者在参数上有区别的。
    对于第一个参数意义都一样，但对第二个参数：
    apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。
    如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])
    同时使用apply的好处是可以直接将当前函数的arguments对象作为apply的第二个参数传入


==========原型、原型链、作用域、立即执行函数、闭包、继承、预编译==========
1.原型的定义：
    原型是function对象的一个属性，它定义了构造函数制造出来的对象的公共祖先。
    通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。
    有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，
    这样的原型上还有原型的结构就构成了原型链。

    /注意:
    1.绝大部分的对象最终都会继承自Object.prototype这个对象。
    并不是所有的对象都有原型，undefined null也都没有原型。

    当我们通过的一个对象改变了原型上引用值类型的属性的话，那么所有对象的这个属性的值都会随之更改.
    但是对象并不能删除原型上的属性。
    谁调用这个方法，这个方法中的this就指向这个调用它的对象。/

2.原型链

    有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，这样的原型上还有原型的结构就构成了原型链。
    当我们查找son上的属性的时候，如果son自身有属性，那么就打印出来，如果没有，就向上查找原型father，如果father上面还有这个属性，那么继续向上查找grandfoo，如果有就输出，如果没有就返回undefined。
    这种链式的查询结构就叫做原型链。

3.作用域:
    es5的作用域有全局作用域和函数作用域，es6中添加了块级作用域
    函数作用域：
    定义：变量（变量作用域又称为上下文）和函数生效（能被访问）的区域
    JavaScript的函数是可以产生作用域的。

    /注意：
    如果在函数作用域里面声明变量没有用var的话，那么就声明了一个全局变量。
     同时，两个不同作用域（除了全局作用域）之间是不能互相访问的/

4.作用域链
    由于函数可以互相嵌套，作用域之间自然也会产生互相嵌套的关系，这个时候就会产生作用域链。
    当代码在一个环境中执行时，会创建变量对象的一个作用域链来保证对执行环境的有权访问的变量和函数的有序访问
    作用域第一个对象始终是当前执行代码所在环境变量对象


5.立即执行函数
    是解闭包的一个重要方法。但是注意闭包是没有办法解除的，
    我们只能通过另一个新闭包来消除上一个闭包的影响。

    定义：立即执行函数不需要被定义，直接执行，执行完毕之后直接释放。

6.闭包
    闭包就是能够读取其他函数内部变量的函数.
    不同作用域之间不能够互相访问，但是我们如果在一个函数内部再定义一个函数，并且这个内部函数与外部函数的变量有关联，
    那么我们就可以通过返回这个内部的函数，然后来访问外部函数里面的变量。
    这个函数返回了一个依赖于这个函数的新函数，也就是说这个没有被销毁的新函数的作用域链中还存在着
    对原本函数的作用域的引用，就导致我们原本的函数的上下文不会被销毁，
    我们称返回的这个新函数是原本函数的闭包函数。

    /闭包的缺点：

    1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，
    所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。
    解决方法是，在退出函数之前，将不使用的局部变量全部删除。/


7.继承
几种方式:
    1.传统方式使用原型链继承 浪费继承了太多无用属性
    2.构造函数
    用call和apply 改变this指向
    3.共享原型
    就是父子构造函数一样
    缺点：无法改变子类原型 要改只能改一个
    4.圣杯模式
        /原理： 函数的原型等于父级的原型 这样改变一个就不会改变父级属性
        写一个新的中间的构造函数 把p的原型给f的原型 通过new一个f让他等于c的原型
        共享一下f和p的原型 通过f构造出c的原型  共享原型有一个问题  构造出的对象可以改变原型上的方法
        p=f  C = new F/

        var inherit  = (function(){
        var F = function(){}
        return function(C,P){
            F.prototype = P.prototype;
            C.prototype = new F();
            C.prototype.constructor = C;
            C.prototype.uber = P.prototype;//最后再补充一下 构造完这些 我是由谁来的 就是P.prototype
            }
        }());

7(+).对象如何查看构造自身的构造函数
    在prototype里面，有一个隐式的属性叫做constructor，这个属性记录的就是对象的构造器，里面存的就是构造函数。
    console.log(oPerson.constructor); // Person();
深层克隆
    function deepCopy(src,tar){
        var tar= tar|| {} ;
        for (var prop in src){
                if (typeof (src[prop]) == 'object'){
                    tar[prop] = (src[prop].constructor === Array ) ? [] : {};
                    deepCopy(src[prop],tar[prop]);
                }else {
                    tar[prop] = src[prop];
                }
        }

        return tar;
    }


8.预编译

    预编译前奏
        1.imply global 暗示全局变量
        .如果任何变量未经声明就赋值使用，此变量就会为全局对象window所有，并且成为window对象的一个属性。
        2.一切声明的全局变量，都是window的属性。
        //区别在于：经过声明的全局变量不能通过delete操作来删除，但是未经声明的全局变量可以被删除

    预编译时this指向window。
    1.创建AO对象。
        首先第一步，创建一个AO对象（执行器上下文）。var AO = {};

    2.寻找形参和变量声明，将变量和形参作为AO对象的属性名添加到对象中，值为undefined。值得注意的是，函数声明不叫变量。

    3.将实参值和形参值相统一。这里因为属性名都已经存在了，所以直接赋值就可以了。

    4.在函数体里面寻找函数声明，将函数名作为属性名，值为这个函数的函数体。

    /注意：
    函数在执行的前一刻会产生一个上下文，这个上下文就是Activeaction Object对象，简称AO对象。AO = {}
    这个对象是空的，但是里面有一些我们看不到的却存在的隐式属性，比如this: window属性和arguments: [];属性/
    这个对象用来存放一些属性和方法，这些属性和方法就按照前面的四步来产生。


==========JS异步加载==========
背景：
    script标签的特点是会阻塞后面的DOM解析，只有当script标签下载完成并且全部执行完之后，浏览器才会继续解析DOM。
    一旦网速不好，那么整个网站将等待js加载而不进行后续渲染。

    html5标准引入了另一套异步加载js的方法
    以前有一种写法是将script标签写在body的最后面，等在DOM全部解析完成之后才加载js。

1.js异步加载的三种方案：

a.defer异步加载

    我们在script标签的行间写一个defer=“defer”或者直接写defer，就可以让这个script变成异步加载了。但是这种异步只是针对下载方面，
    只有等DOMTree全部解析完成（不包括下载完里面的资源）后才会异步执行。而且这个方法只有IE和一些高版本的firefox和chrome可以用。

    不过这一种方式可以在script标签里面写代码。

    注意：IE6和IE7的异步加载最多只能有2个，当多余两个的时候必须等前两个加载完才会加载第三个。

    所有defer的js代码都保证按照顺序执行。

b.async异步加载

    async是asynchronous的缩写，它是html5的标准，下载完成之后就会立即异步执行，这种方法除了IE6-IE8其他的浏览器都好用

    async的js代码不能保证是顺序执行的。

    兼容性写法：

        直接写两个script标签，一个是defer，一个是async。
        但是这种方法有缺陷：IE高版本会加载两遍引起冲突，有些浏览器两个都没有会一个都加载不出来。
        所以我们就需要用async方法了

异步加载js不允许使用document.write这个方法。它会清除文档流，一旦执行就会把全部的标签都清除掉，包括自身的script标签。

c.w3c的标准规定：动态添加的script标签是异步的。


2.封装一个兼容性的异步加载js的函数

function asyncLoaded(url, callback){
    var script = document.createElement('script');
    script.type = 'text/javascript';
    if(script.readyState){//IE和高版本的chrome、firefox    .readyState 对象的状态  非零是读取中
        script.onreadystatechange = function(){
            // onreadystatechange状态改变触发器
            if(script.readyState = 'loaded' || script.readyState == 'complete'){
                script.onreadystatechange = null;
                callback && callback();
            }
        }
    }else{
    script.onload = function(e){//Safari Chrome Opera Firefox
        callback && callback();
        }
    }
    script.src = url;
    document.body.appendChild(script);
}


3.JS加载时间线（performace timing line）

1、创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = ‘loading’。
2、遇到link外部css，创建线程加载，并继续解析文档。
3、遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。
4、遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。 对于async属性的脚本，脚本加载完成后立即执行。
（异步禁止使用document.write()）,而defer是等DOMTree解析完成后才执行
5、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。
6、当文档解析完成，document.readyState = ‘interactive’。
7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,
但同样禁止使用document.write()）;
8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，
转化为事件驱动阶段。
9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window
对象触发load事件。
10、从此，以异步响应方式处理用户输入、网络事件等





==========事件==========
事件是交互体验的核心功能

    事件是每一个浏览器本来就有的，我们只是给相应的事件添加了一个回调函数。

1、拖拽事件
    div.addEventListener('mousedown', function (e){
        var disX = e.clientX - parseInt(getStyle(this, 'left')),
            disY = e.clientY - parseInt(getStyle(this, 'top'));
        document.addEventListener('mousemove', mouseMove, false);
        div.addEventListener('mouseup', function (e) {
            document.removeEventListener('mousemove', mouseMove, false);
        }, false);
    }, false);

    function mouseMove(e) {
        div.style.left = e.clentX - disX + 'px';
        div.style.top = e.clientY - disY + 'px';
    }

2、绑定事件
    1.句柄方式
        虽然句柄方式的兼容性很好，但是一个元素的一种事件只能绑定一个函数。
        事件监听就会把处理函数放入执行队列，等待js引擎来执行。

    2.ele.addEventListener(type, handle, false)方法。
        一种事件可以绑定多个函数，但是同一个处理函数只能绑定一次。 IE9以下不兼容。
        第一个参数是事件类型，第二个参数是处理函数，第三个参数是是否捕获。

    3.ele.attachEvent(‘on’ + type, handle)
        这个方法是IE独有的方法，一个事件同样可以绑定多个处理函数。
        当同一个函数绑定多次的时候，addEventListener是只执行一次，但是attachEvent会绑定几次执行几次。

        试题：使用原生js，addEventListener，为每一个li绑定一个点击事件，输出他们的顺序。
        这里就要注意这个题考察的不仅仅是绑定事件，更多的是闭包的运用。


        var $Li = document.getElementsByTagName('li');
        for (var i = 0, len = $Li.length; i < len; i++) {
        (function (n) {
            $Li[n].addEventListener('click', function () {
                    console.log(n);
            },false);
        } (i))
    }

3、事件处理程序的运行环境
    1.句柄绑定方式中，函数里面的this指向元素本身。

    2.addEventListener方式中，函数里面的this也是指向元素本身。

    3.attachEvent中，函数里面的this指向的是window而不是元素本身，这算是IE的一个BUG。
    针对这种情况，我们就需要把函数提取出来，然后在attachEvent的时候用call来改变函数内部this的指向。

        兼容性的事件绑定函数
        function attachEvent(ele, type, handle) {
            if (ele.addEventListener) {
                ele.addEventListener(type, handle, null);
            }else if (ele.attachEvent) {
                ele['temp' + type + handle] = handle;
                ele[type + handle] = function () {
                    ele['temp' + type + handle].call(ele);
                };
                ele.attachEvent('on' + type, ele[type + handle]);
            }else {
                ele['on' + type] = handle;
            }
        }

    IE的方法中我们用了一个匿名函数，这样这个函数就无法解除绑定了，因此可以优化成命名函数。


4、解除事件处理程序
    1.句柄方式
        ele.onclick=null
         这样很简单的就可以解除绑定的事件处理函数了。

    2.ele.removeEventListener(type, handle, false)

    针对的addEventListener的解除绑定。

    但是这里要注意，只有命名函数才可以解除绑定，当绑定的函数是匿名函数的时候，是没有办法解除绑定的。


    3.ele.detachEvent(‘on’ + type, handle)

    针对IE的attachEvent的解除绑定。

    也是同一个函数才可以解除绑定，匿名函数无法解除绑定


    解除绑定事件
    function remvoeEvent(ele, type, handle) {
          if(ele.removeEventListener) {
                ele.removeEventListener(type, handle, false);
          }else if (ele.detachEvent) {
                ele.detachEvent('on' + type, handle);
          }else {
                ele['on' + type] = null;
          }
    }





5、事件处理模型——事件冒泡、事件捕获
    1. 什么叫冒泡？

        在结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，子元素冒泡向父元素，结构上的自底向上。

        大部分事件都有事件冒泡现象，并且所有的浏览器都有事件冒泡。
        并不是所有的事件都有冒泡，focus、blur、change、submit、reset、select等方法就没有事件冒泡现象。

        addEventListener最后一个参数就是是否开始事件捕获，当我们填true的时候，就代表开启了事件捕获。只要开启了事件捕获，
        就不会冒泡了，如果不捕获的话，就遵循事件冒泡。因为addEventListener只有chrome有，因此事件捕获也只有chrome浏览器有。

        当事件冒泡和事件捕获同时存在的时候，事件冒泡和事件捕获的触发顺序则为：先捕获，再冒泡。

    2.取消冒泡和阻止默认事件
         1.w3c标准方法：event.stopPropagation()
            IE9以及以下的版本不支持这个方法。

         2.event.cancelBubble = true
            这个属性是IE的，不过一些高版本的浏览器也有这个属性，只要让这个属性的值等于true，同样也可以取消事件冒泡。

            封装一个兼容性的取消事件冒泡的方法：


                    function stopBubble(event) {
                        if(event.stopPropagation) {
                            event.stopPropagation();
                        }else {
                            event.cancelBubble = true;
                        }
                    }

    3.默认事件

        当我们在浏览器中点击右键，会弹出一个菜单，这就是一个默认事件contextmenu。还有a标签，即使我们不写跳转的页面，
        也会自动刷新页面，这也是一个默认事件。

        移动端的默认事件更多。

        默认事件有好的也有不好的，这就需要我们把不需要的默认事件阻止掉。


    4.阻止默认事件

            1.return false
                我们只要在处理函数最后写上 return false就可以阻止默认事件了,这种写法只能用在句柄方式绑定的事件上。

            2.e.preventDefault()
                 这是w3c标准的阻止默认事件的方法，句柄也同样可以使用。不过IE9以下不兼容。

            3.e.returnValue = false
                这个是IE的方法，事件源对象上的属性returnValue代表是否有默认事件，直接返回false就可以阻止
                默认事件了。现在高版本的浏览器也有这个属性。

            封装一个兼容性的阻止默认事件的方法
            function cancelHandler(event) {
                if(event.preventDefault) {
                    event.preventDefault();
                }else{
                    event.returnValue = false;
                }
            }

6、事件对象
    在IE中，系统不会把事件对象传到方法中，因此我们的参数e或者event在IE中是不好用的，IE会把事件对象传递到window.event上，
    所以当我们使用事件对象的时候，就要写兼容性的写法：

                var event = e || window.event;

7、事件委托及拓展
    1.事件源对象
        我们现在有一个ul，下面有十万个li，当我们给父级的ul添加第一个点击事件之后，由于事件冒泡的存在，不论我们点击哪一个li都会
        调用父级的点击事件处理函数，这个时候触发父级ul的点击函数的那个li就被称之为事件源对象。

        event.target 是火狐的获取事件源对象

        event.srcElement 是IE的获取事件源对象

        chrome两种都有

    2.事件源对象的时候也需要写兼容性写法


        oUl.addEventListener('click', function (e) {
            //获取事件对象
            var event = e || window.event;
            //获取事件源对象
            var tar = event.target || event.srcElement;
                console.log(tar);
            }, false);

    /注意：我们利用事件源对象和事件冒泡来处理的方式就叫做事件委托。/

    3.什么是事件委托：
        通俗的讲，事件就是onclick，onmouseover，onmouseout，等就是事件，委托呢，就是让别人来做，这个事件本来是加在某些元素上的，
        然而你却加到别人身上来做，完成这个事件。
        事件委托就是把事件绑定到父级上，利用事件冒泡，点击子集就会触发父级上的方法 有个好处就是 不用一个一个给子集绑定事件
       // css3动画效果的时候 鼠标移进去 让一个方块变小
        也就是：利用冒泡的原理，把事件加到父级上，触发执行效果。

   4.事件委托的好处：

        1.管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。

        2.可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。

        3.JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。

        4.事件委托很好地利用了"事件冒泡"。当点击子元素，根据"事件冒泡"，该子元素的父级元素捕获了该次点击事件，并触发自己的方法。


   5.模型将事件处理流程分为三个阶段：
        一、事件捕获阶段，
        二、事件执行阶段，
        三、事件起泡阶段。

      /  事件捕获阶段：事件从最上一级标签开始往下查找，直到捕获到事件目标(target)。
      /  事件冒泡阶段：事件从事件目标(target)开始，往上冒泡直到页面的最上一级标签。

      自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过addEventListener函数，它有三个参数，第三个参数若是true，
      则表示采用事件捕获，若是false，则表示采用事件冒泡。

      ele.addEventListener('click',doSomething2,true)
            true=捕获
            false=冒泡


    6.传统绑定事件方式
        在一个支持W3C DOM的浏览器中，像这样一般的绑定事件方式，是采用的事件冒泡方式。

        ele.onclick = doSomething2

        /IE浏览器
        如上面所说，IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，
        它提供了另一个函数attachEvent。

        ele.attachEvent("onclick", doSomething2);

        附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。

        /事件的传播是可以阻止的：
        • 在W3c中，使用stopPropagation（）方法
        • 在IE下设置cancelBubble = true；
        在捕获的过程中stopPropagation（）；后，后面的冒泡过程也不会发生了~
        /3.阻止事件的默认行为，例如click <a>后的跳转~
        • 在W3c中，使用preventDefault（）方法；
        • 在IE下设置window.event.returnValue = false;
        /4.不是所有的事件都能冒泡，例如：blur、focus、load、unload，

    7.果你将监听器安放到它们的父元素上呢？你如何能知道是那个子元素被点击了？

        简单：当子元素的事件冒泡到父ul元素时，你可以检查事件对象的target属性，捕获真正被点击的节点元素的引用。
        下面是一段很简单的JavaScript代码，演示了事件委托的过程：

            // 找到父元素，添加监听器...
            document.getElementById("parent-list").addEventListener("click",function(e) {
                // e.target是被点击的元素!
                // 如果被点击的是li元素
                if(e.target && e.target.nodeName == "LI") {
                    // 找到目标，输出ID!
                    console.log("List item ",e.target.id.replace("post-")," was clicked!");
                }
            });

        第一步是给父元素添加事件监听器。当有事件触发监听器时，检查事件的来源，排除非li子元素事件。如果是一个li元素，
        我们就找到了目标！如果不是一个li元素，事件将被忽略。这个例子非常简单，UL和li是标准的父子搭配。让我们试验一些差异比较大的元素搭配
        。假设我们有一个父元素div，里面有很多子元素，但我们关心的是里面的一个带有”classA” CSS类的A标记：

        // 获得父元素DIV, 添加监听器...
        document.getElementById("myDiv").addEventListener("click",function(e) {
            // e.target是被点击的元素
            if(e.target && e.target.nodeName == "A") {
                // 获得CSS类名
                var classes = e.target.className.split(" ");
                // 搜索匹配!
                if(classes) {
                    // For every CSS class the element has...
                    for(var x = 0; x < classes.length; x++) {
                        // If it has the CSS class we want...
                        if(classes[x] == "classA") {
                            // Bingo!
                            console.log("Anchor element clicked!");

                            // Now do something here....

                        }
                    }
                }

            }
        });

    上面这个例子中不仅比较了标签名，而且比较了CSS类名。虽然稍微复杂了一点，但还是很具代表性的。
    比如，如果某个A标记里有一个span标记，则这个span将会成为target元素。这个时候，我们需要上溯DOM树结构，找到里面是否有一个 A.classA 的元素。






==========脚本化CSS==========
    读写CSS样式
    每一个dom元素都有一个属性style，dom.style里面存放的这个元素的行间样式，我们可以通过这个属性来读写元素的行间样式。

    1.我们碰到float这样的关键字属性的时候，前面要加一个css前缀。

    float—>cssFloat

    2.复合属性必须拆解

    border: 1px solid red;

    这种属性是不允许出现的，只能写border-width、border-color、border-style。

    3.当css中的样式是用“-”连接起来的时候，我们要变成小驼峰式写法。

    background-color —> backgroundColor;

    这个属性只能读写行间样式，我们写在css的样式是不能获取的，因此我们通过这个属性加样式的时候要注意权重值问题。

    同时，我们在js中写样式只能往行间写，永远也写不到css文件里面。
<!--
//查询计算样式-->
    window上面有一个方法叫做getComputedStyle可以来获取元素的计算样式，也就是css样式。
    window.getComputedStyle(ele. null);
    //这里的样式是取优先级最高的，不只是行间样式，所有的只要是表现出来的样式都可以获取出来。
    同时，返回的计算样式的值都是绝对值，没有相对单位。
   // 第一个参数是我们要获取的元素。第二个参数是一个字符串，代表我们是否要获取这个元素上面的某一个伪元素，
    如果不的话，就填写null，否则就填写要获取的这个元素的哪一个伪元素。



//但是很遗憾的是IE8以及以下的版本不兼容这个方法,IE8有一个特殊的样式currentStyle。
dom.currentStyle也会返回一个样式表，和上面的基本一样，唯一的区别在于返回的计算样式的值不是经过转换的绝对值，而是我们写什么值就会返回什么值
<!--
封装一个兼容性的获取样式的函数-->
    function getStyle(obj, prop, fake) {
        var fake = fake || null;
        if(obj.currentStyle) {
            return obj.currentStyle[prop];
        }else {
            return window.getComputedStyle(obj, fake)[prop];
        }
    }

    脚本化样式表

在document上有一个属性叫做styleSheets，这个属性储存了一个html文档所有的css样式表的集合，我们可以来操作style标签，
不过在实际中基本是用不到的


+++++++++经典题++++++++++
14： 如何将数组去重说说你的思路
    Array.prototype.unique = function () {
      var len = this.length,
      arr = [],
      obj = {};
      for (var i = 0; i < len; i++) {
            if (!obj[this[i]]) {
                  obj[this[i]] = 1;
                  arr.push(this[i]);
            }
      }
      return arr;
    }
用一个空数组和空对象以及一个循环就可实现
当我们数组中的这个数据出现过一次之后，我们就在obj中将这个元素的值的位置标记成1，后面如果出现相同的属性值，因为这个位置已经是1了，
所以就不会添加到新数组里面，从而达到了去重的效果。


==========模块化开发==========
1.模块化开发定义：
    模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。也就是说
    ，把一个巨大的系统代码，被整合优化分割成逻辑性很强的模块，这些模块的特点是高内聚，低耦合所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。


2.前端采用模块化开发，使得开发体验大大增强，摆脱了很多需要人力去做且容易出错的点，使得代码管理更加清晰、规范。主要表现为以下几点：

    减少命名冲突，消除全局变量
    一个模块一个文件，组织更清晰
    依赖自动加载，按需加载
    其中文件按需加载，依赖自动管理，使得更多精力去关注模块代码本身，开发时不需要在页面上写一大堆script引用，一个require初始化模块就搞定。
    不需要每增加一个文件，还要到HTML或者其他地方添加一个script标签或文件声明。

3.前端模块化规范标准

    CommonJs (Node.js)
    AMD (RequireJS)
    CMD (SeaJS)

    1.CommonJs

        CommonJS是服务器模块的规范，Node.js采用了这个规范。根据CommonJS规范，一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，
        在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。

    2.AMD (RequireJS)

        由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，因此CommonJS规范比较适用。但是，
        如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。

    3.CMD (SeaJS)

        CMD规范和AMD类似，都主要运行于浏览器端，写法上看起来也很类似。主要是区别在于模块初始化时机，AMD中只要模块作为依赖时，就会加载并初始化，而CMD中，
        模块作为依赖且被引用时才会初始化，否则只会加载

    /注意：
    兼容AMD、CMD及非模块化
        很多时候如果我们引用第三方组件时，并没有采用模块化开发，通常我们自己需要包装一下或通过模块加载器的shim插件支持模块化引用依赖。现在很多第三方库已
        经默认支持AMD规范的引用，根据以上模块定义规范，开放给第三方使用的组件能兼容不同的规范/

4.模块化开发上线部署

    压缩
    合并
    更新版本
    1.压缩
        不能直接压缩：因为模块加载器在分析模块的依赖时，会先将模块的工厂函数factory.toString()，然后通过正则匹配require局部变量，这样意味着不能直接
        通过压缩工具进行压缩，若require这个变量被替换，加载器与自动化工具将无法获取模块的依赖。

    2.合并
        不能直接合并：我们在开发时，通过是省略模块的ID的，如果多个模块直接合并成一个文件，这样加载器无法区分不同模块了。

        所以采用模块化开发上线部署时，压缩前通常通过工具先提取依赖，这样require就可以当做普通变量直接压缩了，同时也不再需要加载器分析提取依赖，对于
        提升性能也是蛮有好处的。合并前同样也需要借助工具先提取各个模块的ID，然后才能按照合并配置进行合并。

5.FIS的集成解决方案

用过fis的同学都知道，采用fis开发，整体过程相当顺畅，对于前端开发、性能、部署各方面的问题基本都考虑到了，内置的小巧mod.js加载器，就是一个特别轻量的模块加载器，不需要做依赖分析，fis强大的编译能力已经提前提取了依赖关系并生成jsmap.json。已经前置依赖了，一个轻量的加载器足足够了，
编译的同时自动修改新生成的版本号，整个过程在fis下轻松完成。

6.语言扩展能力 (less, coffee, jade…)
前端模板预编译
xss自动转义 无段手动干预
多域名支持，动态切换
编译后自动修改版本号 (包括图片的引用)
线上本地调试功能 ……


==========IE6兼容问题==========
IE6的兼容性问题：

    1、IE6怪异解析之padding与border算入宽高
    原因：未加文档声明造成非盒模型解析
    解决方法：加入文档声明<!doctype html>

    2、IE6在块元素、左右浮动、设定marin时造成margin双倍（双边距）  
    解决方法：display:inline

    3、以下三种其实是同一种bug，其实也不算是个bug，举个例子：父标签高度20，子标签11，垂直居中，20-11=9，9要分给文字的上面与下面，怎么分？IE6就会与其它的不同，所以，尽量避免。
    1）字体大小为奇数之边框高度少1px
    解决方法：字体大小设置为偶数或line-height为偶数
    2）line-height，文本垂直居中差1px
    解决方法：padding-top代替line-height居中，或line-height加1或减1
    3）与父标签的宽度的奇偶不同的居中造成1px的偏离
    解决方法：如果父标签是奇数宽度，则子标签也用奇数宽度;如果是父标签偶数宽度，则子标签也用偶数宽度

    4、内部盒模型超出父级时，父级被撑大
    解决方法：父标签使用overflow:hidden

    5、line-height默认行高bug
    解决方法：line-height设值

    6、行标签之间会有一小段空白
    解决方法：float或结构并排(可读性差，不建议)

    7、标签高度无法小于19px
    解决方法：overflow: hidden;

    8、左浮元素margin-bottom失效
    解决方法：显示设置高度 or 父标签设置_padding-bottom代替子标签的margin-bottom or 再放个标签让父标签浮动，子标签
    margin- bottom，即(margin-bottom与float不同时作用于一个标签)

    9、img于块元素中，底边多出空白
    解决方法：父级设置overflow: hidden; 或 img { display: block; } 或 _margin: -5px;

    10、li之间会有间距
    解决方法：float: left;

    11、块元素中有文字及右浮动的行元素，行元素换行
    解决方法：将行元素置于块元素内的文字前

    12、position下的left，bottom错位
    解决方法：为父级(relative层)设置宽高或添加*zoom:1

    13、子级中有设置position，则父级overflow失效
    解决方法：为父级设置position:relative

    以下是补充：上面要先看

    1、终极方法：条件注释
    <!--[if lte IE 6]> 这段文字仅显示在 IE6及IE6以下版本。 <![endif]-->
    <!--[if gte IE 6]> 这段文字仅显示在 IE6及IE6以上版本。 <![endif]-->
    <!--[if gt IE 6]> 这段文字仅显示在 IE6以上版本（不包含IE6）。 <![endif]-->
    <!--[if IE 5.5]> 这段文字仅显示在 IE5.5。 <![endif]-->
    <!--在 IE6及IE6以下版本中加载css-->
    <!--[if lte IE 6]> <link type="text/css" rel="stylesheet" href="css/ie6.css" mce_href="css/ie6.css" /><![endif]-->
    缺点是在IE浏览器下可能会增加额外的HTTP请求数。

    2、CSS选择器区分
    IE6不支持子选择器；先针对IE6使用常规申明CSS选择器，然后再用子选择器针对IE7+及其他浏览器。

    复制代码代码如下:

    /* IE6 专用 */
    .content {color:red;}
    /* 其他浏览器 */
    div>p .content {color:blue;} -->

    3、PNG半透明图片的问题
    虽然可以通过JS等方式解决，但依然存在载入速度等问题，所以，这个在设计上能避免还是尽量避免为好。以达到网站最大优化。
    4、IE6下的圆角
    IE6不支持CSS3的圆角属性，性价比最高的解决方法就是用图片圆角来替代，或者放弃IE6的圆角。

    5、IE6背景闪烁
    如果你给链接、按钮用CSS sprites作为背景，你可能会发现在IE6下会有背景图闪烁的现象。造成这个的原因是由于IE6没有将背景图缓存，每次触发hover的时候都会重新加载，可以用JavaScript设置IE6缓存这些图片：

    复制代码代码如下:

    document.execCommand("BackgroundImageCache",false,true);

    6、最小高度
    IE6 不支持min-height属性，但它却认为height就是最小高度。解决方法：使用ie6不支持但其余浏览器支持的属性!important。

    复制代码代码如下:

    #container {min-height:200px; height:auto !important; height:200px;}

    7、最大高度

    复制代码代码如下:

    //直接使用ID来改变元素的最大高度
    var container = document.getElementById('container');
    container.style.height = (container.scrollHeight > 199) ? "200px" : "auto";
    //写成函数来运行
    function setMaxHeight(elementId, height){
    var container = document.getElementById(elementId);
    container.style.height = (container.scrollHeight > (height - 1)) ? height + "px" : "auto";
    }
    //函数示例
    setMaxHeight('container1', 200);
    setMaxHeight('container2', 500);

    8、100% 高度
    在IE6下，如果要给元素定义100%高度，必须要明确定义它的父级元素的高度，如果你需要给元素定义满屏的高度，就得先给html和body定义height:100%;。

    9、最小宽度
    同max-height和max-width一样，IE6也不支持min-width。

    复制代码代码如下:

    //直接使用ID来改变元素的最小宽度
    var container = document.getElementById('container');
    container.style.width = (container.clientWidth < width) ? "500px" : "auto";
    //写成函数来运行
    function setMinWidth(elementId, width){
    var container = document.getElementById(elementId);
    container.style.width = (container.clientWidth < width) ? width + "px" : "auto";
    }
    //函数示例
    setMinWidth('container1', 200);
    setMinWidth('container2', 500);

    10、最大宽度

    复制代码代码如下:

    //直接使用ID来改变元素的最大宽度
    var container = document.getElementById(elementId);
    container.style.width = (container.clientWidth > (width - 1)) ? width + "px" : "auto";
    //写成函数来运行
    function setMaxWidth(elementId, width){
    var container = document.getElementById(elementId);
    container.style.width = (container.clientWidth > (width - 1)) ? width + "px" : "auto";
    }
    //函数示例
    setMaxWidth('container1', 200);
    setMaxWidth('container2', 500);

    11、双边距Bug
    当元素浮动时，IE6会错误的把浮动方向的margin值双倍计算。个人觉得较好解决方法是避免float和margin同时使用。

    12、清除浮动
    如果你想用div(或其他容器)包裹一个浮动的元素，你会发现必须给div(容器)定义明确的height、width、overflow之中一个属性（除了auto值）才能将浮动元素严实地包裹。

    复制代码代码如下:

    #container {border:1px solid #333; overflow:auto; height:100%;}
    #floated1 {float:left; height:300px; width:200px; background:#00F;}
    #floated2 {float:right; height:400px; width:200px; background:#F0F;}
    更多：http://www.twinsenliang.net/skill/20090413.html

    13、浮动层错位
    当内容超出外包容器定义的宽度时，在IE6中容器会忽视定义的width值，宽度会错误地随内容宽度增长而增长。
    浮动层错位问题在IE6下没有真正让人满意的解决方法，虽然可以使用overflow:hidden;或overflow:scroll;来修正， 但hidden容易导致其他一些问题，scroll会破坏设计；JavaScript也没法很好地解决这个问题。所以建议是一定要在布局上避免这个问题发 生，使用一个固定的布局或者控制好内容的宽度（给内层加width）。

    14、躲猫猫bug
    在IE6和IE7下，躲猫猫bug是一个非常恼人的问题。一个撑破了容器的浮动元素，如果在他之后有不浮动的内容，并且有一些定义了:hover的链接，当鼠标移到那些链接上时，在IE6下就会触发躲猫猫。
    解决方法很简单：
    1.在（那个未浮动的）内容之后添加一个<span style="clear: both;"> </span>
    2.触发包含了这些链接的容器的hasLayout，一个简单的方法就是给其定义height:1%;

    15、绝对定位元素的1像素间距bug
    IE6下的这个错误是由于进位处理误差造成（IE7已修复），当绝对定位元素的父元素高或宽为奇数时，bottom和right会产生错误。唯一的解决办法就是给父元素定义明确的高宽值，但对于液态布局没有完美的解决方法。

    16、3像素间距bug
    在IE6中，当文本(或无浮动元素)跟在一个浮动的元素之后，文本和这个浮动元素之间会多出3像素的间隔。
    给浮动层添加 display:inline 和 -3px 负值margin
    给中间的内容层定义 margin-right 以纠正-3px

    17、IE下z-index的bug
    在IE浏览器中，定位元素的z-index层级是相对于各自的父级容器，所以会导致z-index出现错误的表现。解决方法是给其父级元素定义z-index，有些情况下还需要定义position:relative。

    18、Overflow Bug
    在IE6/7中，overflow无法正确的隐藏有相对定位position:relative;的子元素。解决方法就是给外包容器.wrap加上position:relative;。

    19、横向列表宽度bug
    如果你使用float:left;把<li>横向摆列，并且<li>内包含的<a>（或其他）触发了 hasLayout，在IE6下就会有错误的表现。解决方法很简单，只需要给<a>定义同样的float:left;即可。

    20、列表阶梯bug
    列表阶梯bug通常会在给<li>的子元素<a>使用float:left;时触发，我们本意是要做一个横向的列表(通常 是导航栏)，但IE却可能呈现出垂直的或者阶梯状。解决办法就是给<li>定义float:left;而非子元素<a>，或者 给<li>定义display:inline;也可以解决。

    21、垂直列表间隙bug
    当我们使用<li> 包含一个块级子元素时，IE6(IE7也有可能)会错误地给每条列表元素（<li>）之间添加空隙。
    解决方法：把<a>flaot并且清除float来解决这个问题；另外一个办法就是触发<a>的hasLayout（如定 义高宽、使用zoom:1;）；也可以给<li> 定义display:inline;来解决此问题；另外还有一个极有趣的方法，给包含的文本末尾添加一个空格。

    22、IE6中的:hover
    在IE6中，除了(需要有href属性)才能触发:hover行为，这妨碍了我们实现许多鼠标触碰效果，但还是有一些法子是可以解决它的。最好是不要用:hover来实现重要的功能，仅仅只用它来强化效果。

    23、IE6调整窗口大小的 Bug
    当把body居中放置，改变IE浏览器大小的时候，任何在body里面的相对定位元素都会固定不动了。解决办法：给body定义position:relative;就行了。

    24、文本重复Bug
    在IE6中，一些隐藏的元素（如注释、display:none;的元素）被包含在一个浮动元素里，就有可能引发文本重复bug。解决办法：给浮动元素添加display:inline;。




ie6在CSS方面的兼容性问题有哪些

    1. 在IE6元素浮动，如果宽度需要内容撑开，就给里面的块元素加浮动。

    2. IE6下最小高度问题：在IE6下元素高度小于19px的时候，会被当作19px处理。解决方案：给元素加 overflow:hidden。

    3. border：1px dotted #000: 1px dotted 在IE6下不支持
    解决方案：切背景平铺

    4. margin传递：解决方案：a.父级或自己浮动;
    b.给元素加 overflow:hidden;zoom:1;

    5. 在IE6下父级有边框的时候，子元素的margin值消失。解决方案：触发父级haslayout(haslayout触发：zoom:1)

    6. IE6下的双边距bug：在IE6下，块元素有浮动和横向的margin值，横向的margin值会被放大成两倍。解决方案：display:inline。

    7. 在IE6、7下li本身没浮动，但是li的内容有浮动，li下边就会产生一个间隙。解决方案：a.给li加浮动;
    b.给li加vertical-align:top ;

    8. 当IE6下最小高度问题和li的间隙问题共存时给li加vertical-align:top 和浮动。

    9. IE6下当一行子元素占有的宽度子和和父级的宽度相差超过3px,或有不满行状态的时候，margin-bottom就会失效。解决方案：无 （自己注意避免）。

    10. IE6下文字溢出BUG： 产生原因：子元素和父级宽度相差小于3px,或两个浮动元素之间有注释或内嵌元素。解决方案：用DIV把注释或内嵌元素包起来。

    11. 当浮动元素和绝对定位元素是并列关系的时候，在IE6下绝对定位元素会失效。解决方案：给定位元素外面包DIV。

    12. 在IE6、7下，子元素有相对定位的话，父级的overflow包不住自己元素。解决方案：给父级加相对定位。

    13. 在IE6下绝对定位元素的父级宽高是奇数的时候，元素的right值和bottom值会有1px的偏差。解决方案：无（自己注意避免）。

    14. 在IE6、7下输入类型的表单控件上下各有1px的间隙。解决方案：加浮动。

    15. 在IE6、7下输入类型的表单控件加border:none无效。解决方案：重置背景。

    16. 在IE6、7下输入类型的表单控件输入文字的时候，背景图片会跟着移动。解决方案：把背景加给父级。

    17. IE6下PNG不透明：解决方案：引入JS文件（DD_belatedPNG_0.0.8a.js）， 使用语法<script>DD_betatedPNG.fix('PNG图片所在块ID或CLSS名（如#div1，.class2）').


    18. 样式优先级：默认<类型<class<id<style(行间)<important 在IE6后面再加一条同样的样式，会破会掉important的作用，会按照默认的优先级顺序来走.






     
     // 2019/3/14


</script>
</body>
</html>